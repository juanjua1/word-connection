'use client'; import React from 'react'; import { AlertTriangle, RefreshCw, Home, Bug } from 'lucide-react'; import { Button } from './Button'; interface ErrorStateProps { error?: Error | string; type?: 'network' | 'validation' | 'server' | 'not-found' | 'generic'; title?: string; message?: string; onRetry?: () => void; onGoHome?: () => void; className?: string; fullScreen?: boolean; } export const ErrorState: React.FC<ErrorStateProps> = ({ error, type = 'generic', title, message, onRetry, onGoHome, className = '', fullScreen = false }) => { const getErrorInfo = () => { switch (type) { case 'network': return { icon: <AlertTriangle className="w-12 h-12 text-orange-500" />, title: title || 'Error de conexión', message: message || 'No se pudo conectar con el servidor. Verifica tu conexión a internet.', color: 'orange' }; case 'validation': return { icon: <AlertTriangle className="w-12 h-12 text-yellow-500" />, title: title || 'Error de validación', message: message || 'Los datos proporcionados no son válidos.', color: 'yellow' }; case 'server': return { icon: <Bug className="w-12 h-12 text-red-500" />, title: title || 'Error del servidor', message: message || 'Ocurrió un error interno en el servidor. Intenta nuevamente.', color: 'red' }; case 'not-found': return { icon: <AlertTriangle className="w-12 h-12 text-blue-500" />, title: title || 'No encontrado', message: message || 'El recurso solicitado no se encontró.', color: 'blue' }; default: return { icon: <AlertTriangle className="w-12 h-12 text-gray-500" />, title: title || 'Ha ocurrido un error', message: message || 'Algo salió mal. Intenta nuevamente.', color: 'gray' }; } }; const errorInfo = getErrorInfo(); const containerClasses = fullScreen ? 'min-h-screen flex items-center justify-center bg-gradient-to-br from-slate-50 to-slate-100 ' : 'flex items-center justify-center p-8'; return ( <div className={`${containerClasses} ${className}`}> <div className="max-w-md w-full text-center"> <div className="mb-6 flex justify-center"> {errorInfo.icon} </div> <h2 className="text-xl font-bold text-slate-900 mb-3"> {errorInfo.title} </h2> <p className="text-slate-600 text-slate-400 mb-6 leading-relaxed"> {errorInfo.message} </p> {error && typeof error === 'object' && ( <details className="mb-6 text-left"> <summary className="cursor-pointer text-sm text-slate-500 hover:text-slate-700 text-slate-400 :text-slate-300"> Detalles técnicos </summary> <pre className="mt-2 p-3 bg-slate-100 bg-slate-800 rounded-lg text-xs text-slate-700 text-slate-300 overflow-auto"> {error.message || String(error)} </pre> </details> )} <div className="flex flex-col sm:flex-row gap-3 justify-center"> {onRetry && ( <Button variant="primary" onClick={onRetry} leftIcon={<RefreshCw className="w-4 h-4" />} > Intentar nuevamente </Button> )} {onGoHome && ( <Button variant="outline" onClick={onGoHome} leftIcon={<Home className="w-4 h-4" />} > Ir al inicio </Button> )} </div> </div> </div> ); }; interface ErrorBoundaryState { hasError: boolean; error?: Error; } interface ErrorBoundaryProps { children: React.ReactNode; fallback?: React.ComponentType<{ error?: Error; resetError: () => void }>; } export class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> { constructor(props: ErrorBoundaryProps) { super(props); this.state = { hasError: false }; } static getDerivedStateFromError(error: Error): ErrorBoundaryState { return { hasError: true, error }; } componentDidCatch(error: Error, errorInfo: React.ErrorInfo) { console.error('Error capturado por ErrorBoundary:', error, errorInfo); } resetError = () => { this.setState({ hasError: false, error: undefined }); }; render() { if (this.state.hasError) { if (this.props.fallback) { const FallbackComponent = this.props.fallback; return <FallbackComponent error={this.state.error} resetError={this.resetError} />; } return ( <ErrorState error={this.state.error} type="server" onRetry={this.resetError} fullScreen /> ); } return this.props.children; } } // Hook para manejo de errores export const useErrorHandler = () => { const [error, setError] = React.useState<Error | string | null>(null); const handleError = React.useCallback((error: Error | string) => { console.error('Error handled:', error); setError(error); }, []); const clearError = React.useCallback(() => { setError(null); }, []); return { error, handleError, clearError }; }; 

